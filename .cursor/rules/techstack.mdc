---
description: 
globs: 
alwaysApply: false
---
# Tech Stack Document for ZebraFetch

This document explains the technologies behind ZebraFetch in everyday language. It covers how each piece works and why we chose it to ensure your team (especially IT staff using N8N) can understand and maintain the service.

## 1. Frontend Technologies

Although ZebraFetch is a backend-only service, we provide simple interactive interfaces so engineers and IT staff can explore and test the API without writing code.

• **Swagger UI** • Auto-generated by FastAPI at `/docs` • Lets you click through endpoints, try requests, and see responses in real time

• **ReDoc** • Alternative interactive docs at `/redoc` • Clean, readable layout of the OpenAPI schema

These interfaces boost productivity by removing guesswork and making onboarding as easy as opening a web page.

## 2. Backend Technologies

The core application runs as a Python service that ingests PDFs, decodes barcodes, and returns JSON.

• **Base Image**: `python:3.12-slim-bookworm` • Minimal footprint, fast startup • Official Python release with security updates

• **Web Framework**: FastAPI + Uvicorn • FastAPI handles routing, validation, and OpenAPI generation automatically • Uvicorn is a lightning-fast ASGI server that runs async code efficiently

• **Concurrency**: `asyncio` • Manages up to two parallel jobs without blocking • Simplifies background task scheduling for async scans

• **PDF Rasterizer**: `pdfium-python` • Converts PDF pages to images via a permissive-licensed PDFium engine

• **Barcode Decoder**: `zxing-cpp` via PyBind11 • Industry-tested decoding for 1D and 2D barcodes • Apache-licensed C++ library bound into Python for speed

• **Storage**: SQLite • Lightweight file-based database for job tracking and artifact paths • No separate database server to manage

• **Logging**: Python standard `logging` • Writes plain-text logs to stdout (easy to collect in containers)

• **Configuration**: YAML file (`config.yaml`) or alternate path via `ZF_CONFIG` • Controls timeouts, rate limits, worker pool size, and log format

## 3. Infrastructure and Deployment

We containerize ZebraFetch for consistent deployment and easy scaling.

• **Docker** • Packages the entire application and its dependencies in a single image

• **docker-compose** • Defines how the ZebraFetch service, volumes, and network come up together • Ideal for one-click deployment in Portainer or local testing

• **Portainer** • Web UI for deploying and managing Docker stacks without command-line complexity

• **Version Control**: GitHub • Source code, configuration, and documentation live in a Git repository

• **CI/CD**: GitHub Actions • Steps: 1. **Lint & Format** – Black, Flake8, mypy enforce code style and type correctness 2. **Unit & Integration Tests** – Verify core logic and sample PDF scans 3. **Performance Check** – Ensure 10-page PDF completes under 20 s 4. **Docker Build & Push** – Build image and push to Docker Hub (`zebrafetch/zebrafetch:1.0.0`)

This pipeline ensures every change is tested, linted, and automatically released upon success.

## 4. Third-Party Integrations

ZebraFetch plugs into existing tools without heavy dependencies.

• **N8N** • Triggers ZebraFetch jobs in automation workflows managed by IT staff

• **Paperless-NGX** • Upstream document management system that kicks off barcode extraction

• **Prometheus** • Scrapes metrics from `/metrics` endpoint (e.g., total_requests, job_duration_seconds)

• **Docker Hub** • Central registry for storing and versioning the built Docker images

These integrations make ZebraFetch a drop-in component for your pipeline, without rewriting or complicated adapters.

## 5. Security and Performance Considerations

We’ve built ZebraFetch to be secure by default (within an internal network) and to meet performance targets.

Security Measures:

• **Internal-only access** • Runs behind your TLS termination (e.g., corporate reverse proxy)

• **Authentication Placeholder** • Configurable API-Key or Bearer-token support that you can enable via `config.yaml`

• **Rate Limiting** • Global maximum requests per minute (`max_req_per_min`) set in config (default: unlimited)

Performance Optimizations:

• **Async Processing** • Non-blocking I/O and up to two concurrent jobs in the same container

• **Resource Limits** • Reject files > 100 MB immediately (HTTP 413) to prevent resource exhaustion

• **Timeouts** • Sync scans timeout at 60 s, so runaway jobs don’t tie up workers

• **Stateless Design** • Containers can be scaled horizontally by simply running more instances

Together, these measures ensure a smooth, reliable experience that meets the 99.5 % availability target.

## 6. Conclusion and Overall Tech Stack Summary

ZebraFetch combines a modern Python stack with lightweight containerization to deliver a reliable, easy-to-deploy barcode extraction service. Here’s a quick recap:

• **Python 3.12-slim + FastAPI/Uvicorn** for high-performance, async HTTP handling • **pdfium-python & zxing-cpp (via PyBind11)** for accurate, license-friendly PDF rendering and barcode decoding • **SQLite** for zero-administration job metadata storage • **Docker, docker-compose & Portainer** for simple, repeatable deployments • **GitHub Actions** with Black, Flake8, mypy, tests, and Docker pushes to Docker Hub • **Swagger UI & ReDoc** for instant, interactive API documentation • **Prometheus** metrics and `/healthz` for monitoring and SLA compliance

This carefully chosen stack aligns with the project goal: a drop-in, no-code solution for internal automation pipelines that avoids heavy licensing, exposes rich diagnostics, and scales effortlessly as needs grow. If you have questions or need to tweak any part of this setup, the configuration is centralized in a single YAML file, and the code patterns are straightforward to follow.

